2. c语言如何在单片机中运行
```
gcc -E Hello.c -o hello.i //预处理
gcc -S hwllo.c -o hellos.s //汇编
gcc -s heloo.c -o hello.o //机器码
gcc hellow.c -o hellow // 连接后的源代码
```
点亮一盏发光二极管 c语言和汇编语言
```
#include<STCREG.H>
sbit LED = P0^0;
void main(){
	LED = 0;
}

C:0x0000 020003 LJMP C:0003
C:0x0003 787F MOV R0,#0x7F
CL0x0005 E4 CLR A
C:0x0006 F6 MOV @R0, A
C:0x0007 D8FD DJNZ R0,C:0006
C:0x0009 758107 MOV SP(0x81), #0x07

C:0x000C 02000F LJMP main(C:000F)
	5:void main()
	6:{
	7:	LED = 0;
C:}
----
```

- 汇编指令分类
	- 指令作用对象: 汇编指令:产生机器码, 伪指令:不产生机器码但告诉编译器该怎么做
	- 按寻址方式: 寄存器寻址, 位寻址
	- 按指令功能: 数据传输指令, 算术运算指令, 逻辑运算指令, 位操作指令, 控制转移指令


1. 程序状态字(PSW)

比特位|7|6|5|4|3|2|1|0
-|-|-|-|-|-|-|-|-
名字|CY|AC|F0|RS1|RS0|OV|RSV|P

1. CY: 进位标志. 算术和位指令影响该位.  加法时有进位, 减法时有借位 CY位1, 否则位0
2. AC 辅助进位标志. ADD, ADDC, SUBB指令影响该位, 加法运算第3位或第4位有进位, 减法运算第3位或第4位有借位. 目的方便BCD码加法, 减法的调整
3. F0: 通用标志 位
4. RS1, RS0: 寄存器组选择位
5. OV: 溢出标志位. ADD, ADDC, SUBB, MUL, DIV 影响该位
6. RSV 保留位
7. P 奇偶标志位. **每条指令执行完后设置或清除该位**, 用于表示ACC中1的个数. 如果有奇数个1 设置为1; 否则为0

```
PC指针的低三位表示使用那个寄存器
MOVC 这个指令是访问外部程序存储器的(ROM),主要看(C)
MOVX这个指令是访问外部数据存储器的(RAM), 主要看(X).
```

- 按寻址方式:
	1. 寄存器寻址: 操作数为寄存器的 称为寄存器寻址
		- 如 INC R0 ;(R0)+1-->R0
	2. 直接寻址:指令中有操作数的直接地址 作用于以下三种存储空间
		- 特殊功能寄存器(SFR只能用直接寻址方式访问)
		- 内部数据存储器的低128B(对于8052, 高128B不能直接寻址方式访问)
		- 为地址空间
		- 如 ANL 70H, #48H. 70是目的操作数就是操作的结果保存在这里, #48H是源操作数 就是数据来源; 对于单片机来说所有数据流都是由后到前的. 70H表示直接地址 #48H表示立即数, 也就是说#后面是立即数
	3. 间接寻址: 寄存器保存的是数据的地址 如c的指针
		- 只能用R0或R1做地址指针(对栈操作指令用SP), 寻址内部RAM.  间接寻址也可以访问外部扩展的数据存储器, 用R0,R1或DPTR作为地址指针. 寄存器间接寻址用@表示
		- 间接可访问地址空间:低128B(可以用R0,R1), 高128B(可以用R0,R1)(MCS-52系列), 内部数据存储器的低4为(用R0,R1), 外部的数据存储器(xdata定义)DPTR, R0, R1(访问页存储空间,用pdata定义)
	4. 立即寻址: ACC A,#70H
	5. 基寄存器加变址寄存器间接寻址:如MOVC A,@A+PC, MOVC A,@A+DPTR(相当于数组, DPTR(比较而言PC会移动, DPTR不会移动)表示0号地址,@A表示偏移量)
如果十六进制数用H表示那么如果这个数是英文的话前面必须加0如0E0H不能写E0H(编译时当作变量执行)
```
01H实际就是第0工作区的R1寄存器，只适用于单片机，
PUSH ACC 必须这么写 而不能写成PUSH A
POP ACC 这必须这么写 而不能写成POP A
 如果使用R0,R1 来寻址RAM, R0,R1为低八位,P2高八位,且指针地址是0, 也就是第0页, 即数据存储中的pdata, 并且把r0, r1送到P0口
 如果16进制用H表示, 那么如果第一位是英文字母, 那么首字母要加个0 如 0E0H
```
```
DB 加一 DW 加二
单片机没有不带进位的减法
设(A)=30 执行1000H MOVC A,@A+PC 结果这个指令在CPU内执行时, PC指向下一条指令, MOVC A,@A+PC编译完后是一个字节, 所以PC就指向1001H这个地址. 1001H+30H = 1031H. 也就是最后的寻址空间
BCD码:压缩(一个字节两个)和非压缩(一个字节1一个)

BCD码相加
    5 6            A
  + 6 7            R5
 --------
    B D            (A)=0DBH
     16
 --------
      3
  + 6 0
 --------
  1 2 3            (A)=23H

R1 R0 + R3 R2 = R1 R0(实现16位二进制+16位二进制)
    R1  R0
  + R3cyR2
-----------
    R1 R0
MOV A, R2
ADD A, R0
MOV R0, A
MOV A, R3
ADDC A, R1
MOV R1, A
注意没有 ADD R0+R1, 会报错. 单片机指令有限
要用可以用ADDC代替ADD 但cy要置0

```
- 按指令功能分类
    - 数据传输指令
        - 内部数据(cpu)传输
            - 以累加器A为目的的操作数的4条指令:MOV A,Rn; MOV A,direct; MOV A,@Ri; MOV A,#data
			- 以Rn为目的操作数的3条指令:MOV Rn,A; MOV Rn,direct; MOV Rn,#data
            - 以直接寻址的单元为目的操作数5条指令:MOV P1,A; MOV 70H,R2; MOV 0E0H, 78H; MOV 50H,@R0; MOV 01H, #80H
			- 以寄存器间接寻址的单元为目的操作数指令3条指令: MOV @Ri,A; MOV @Ri,direct; MOV @Ri,#data
            -  16位数据传送指令:
			```
			设(SP)=62H, (62H)=70H, (61H)=30H, 执行下诉指令:
			POP DPH 
			POP DPL
			结果 (DPTR)=7030H, (SP)=60H
			出栈指令可用于恢复CPU
			```
			- 字节交换3条指令 如:XCH A,Rn; XCH A,direct; XCH A,@Ri
			```
			设(A)=80H, (R7)=08H, 执行下诉指令:
			XCH    A,R7
			结果(A)=08,(R7)=80H
			```
			- 半字节交换指令如:XCHD A,@R0 (可以用循环右移 来交换高四位)
			```
			设(A)=15H, (R0)=30H, (30H)=36H ; 执行XCHD A,@R0
			结果(A)=16H, (30H)=35
			```
		- 累加器A与外部数据存储器传送指令 如:MOVX(X表示CPU外部数据存储器) A,@DPTR; MOVX A,@Ri; MOVX @DPTR, A; MOVX @Ri,A
		- 查表指令(从外部程序存储器读取数据指令): MOVC(C表示外部程序存储器, 只读) A,@A+PC; MOVC A,@A+DPTR
		```
		设(DPTR)=8100H, (A)=50H, 执行下述指令:
		MOVC A, @A+DPTR
		结果: 将程序存储器8150H单元中的内容送入A寄存器中, 可以查表范围在64KB程序存储器中任何位置
		```
	- 加法指令(不能直接相加, 会报错, 指令有限):
		- 不带进位的加法指令:ADD A,Rn; ADD A,direct; ADD A,@Ri; ADD A,#data. (n=0~7, i=0,1)
			```
			设(A)=53, (R0)=0FCH, 执行指令
			ADD A,R0 
			结果(A)=4FH, CY=1(进位或借位),AC=0(半进位,低4位向高4位进位), OV=0(溢出), P=1(奇数1, 偶数0)
			1表示有进位
			最高位 次高位   OV
			  1      1    0
			  0      0    0
			  1      0    1
			  0      1    1
			```
		- 带进位加法指令:ADDC A,Rn; ADDC A,direct; ADDC A,@Ri; ADDC A,#data. (n=0~7, i=0,1)
		- 增量指令(不影响PSW):INC A等
		- 十进制调整指令: 10进制按16进制相加然后进行调整:ADD A,R5. DA A
		```
		注意加数和被加数都是BCD码, 并且将结果调整位压缩BCD码
		调整方法(以低4位为例):如果低4位大于9或小于9且有进位,则低4位加06H. 高四位原理一样加60H. 原理类似与余3码
		```
	- 减法指令
		- 带进位减法指令:SUBB
		- 减1指令:DEC
		- 乘除法指令MUL AB. DIV AB(中间不需要逗号, 商在A, 余数在B)
	逻辑运算指令
		- 累加器A的逻辑操作指令
			- 将累加器A清0指令:CLR A
			- 取反指令:CPL A
			- 左环移指令:
			- 带进位左环移指令:RLC A
			- 右环移指令:RR A
			- 带进位右环移指令:RRC A
			- 累加器ACC半字节交换指令: SWAP A(高低4位交换)
		- 两个逻辑运算指令
			- 逻辑与指令:ANL A,Rn. ANL A,direct. ANL A,@Ri.....
			- 位变量传送指令:MOV C,bit. MOV bit,C(通过第一位判断是位地址还是字节地址)
			- 位变量逻辑操作指令
		- 控制转移指令
			- 无条件转移指令(可以只写JMP, 编译器会自己选择那个),长度不一样
				- 短(静)跳转指令: AJMP addr11 (最多跳转11位)
				- 相对跳转指令:SJMP rel
				- 长跳转指令:LJMP addr16 (最多跳转16位)
				- 基址寄存器加变址寄存器间接转移指令:JMP @A+DPTR(类似数组, A是可变的)
			- 条件转移指令
				- 测试条件复合转移指令
					- JZ rel(等于1跳转), JNZ rel(等于0跳转), JC rel, JNC rel (前4个都是基于A寄存器判断的). JB bit,rel. JNB bit,rel. JBC bit,rel(如果bit 是1就跳转, 然后清0)
				- 比较不相等转移指令
					- CJNE A,direct,rel. CJNE A,#data,rel. CJNE Rn,#data,rel. CJNE @Ri,#data,rel
				- 减1不为0转移指令:DJNZ Rn,rel. DJNZ direct,rel
			- 调用的返回指令
				- 短调用指令: ACALL adde11
				- 长调用指令: LCALL addr16
				- 返回指令: RET
				- 空操作: NOP
#### 4汇编语言程序设计
```
ORG 0000H
LJMP MAIN ;系统上电进入主程序
ORG 0003H ;
LJMP INTO_ISR;进入外部中断0服务程序
ORG 000BH
LJMP Timer0_ISR ;进入定时计数中断0服务程序
ORG	0013H
LJMP INT1_ISR ;进入外部中断1服务程序
ORG 001BH
LJMP Timer1_ISR ;进入定时计数中断1服务程序
ORG 0023H
LJMP COM_ISR ;进入串口中断服务程序

MAIN:.... ;系统初始化 
	 .....;主程序部分
LOOP: MOV SP,#Data;设置堆栈指针
	  ... ;主体程序部分
	  LJMP LOOP
Subroutine:   ;子程序部分
		   ...;子程序主体部分
		   RET;返回调用子程序的下一条指令处
INTO_ISR:
		 .... ;外部中断0服务程序主体部分
		 RETI ;返回被中断处的下一条指令处
TAB: ....;定义数据区
     END ;汇编程序结束
```
PC机每压入一次减少1, 单片机每压入一次加1
对单片机来说主程序是死循环的
主程序是死循环+ 中断程序的方式
