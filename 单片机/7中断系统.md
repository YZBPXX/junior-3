#### 第七部分中断系统
> 中断函数不能出现在主函数中
> 中断信号传送到硬件查询中, 然后硬件查询将中断申请地址传给PC指针, 同时告诉CPU准备执行中断服务程序,主程序将下一条指令压栈, 然后CPU执行中断指令
```c
//中断方式点亮发光二极管
#include<STCREG.H>
sbit LED0 = P0^0;
bit FLAG = 0;
void INT0_Start(void) interrupt 0{//0决定了程序必须放到0003H这个位置
	if(FLAG = 0)
		LED0 = 0;
	else 
		LED0 = 1;
	FLAG = !FLAG;
}
void main(){
	IT=1;//下降沿触发
	EX0=1;//开关
	EA=1; //开关
	while(1);
}
```
中断函数和普通函数有哪些区别?
- 中断函数存储位置是固定的
- 执行的是没有预期的
- 属性参数不通

中断类型:
1. 外部中断:$\overline{INT0}, \overline{INT1};P3.2,P3.3$
2. 内部中断:Timer0(T0定时/计数), Timer1;非周期性(只能计数),周期性(可以定时和计数);P3.4,P3.5
3. 串口中断(地址0023H):UART1(RxD/TxD);P3.0,P3.1
> TI,RI 当接收到一第八位数据时硬件自动置1, 软件清0, 执行那个清除那个, 因为只有一个接口, 需要中断服务程序判断TI,RI那个是1, 并且如果同时是1 需要软件判断那个先执行
寄存器:  
> 中断嵌套: 执行低优先级的中断时,产生了高优先级的中断, 此时低优先级的被打断, 去执行高优先级的中断, 当执行完后在返回低优先级的程序
TCON :
1. IT0(响应后硬件清0): 
	- 1 下降沿触发
	- 0 低电平触发
	- 触发后TCON的IE0硬件置位1, CPU响应中断时清0

2. IE寄存器(地址:0xA8; 复位值:00000000B)
	0. EX0:外部中断0允许位; 1允许
	1. ET0:定时/计数器T0的溢出中断允许位; 1允许T0溢出产生中断事件
	2. EX1:外部中断1允许位
	3. ET1:定时/计数器T1的溢出中断允许位
	4. ES:串行接口1中断允许位
	5. EADC:ADC转换中断允许位
	6. ELVD:低电压检测中断允许位
	7. EA:全局中断使能位
3. IP寄存器:
	0. PX0: 与IE类似, 1 是高优先级, 0是低优先级. 一下同理
	1. PT0
	2. PX1
	3. PT1
	4. 
	> 同级优先级不会被打断
	> 同一个自然优先级中,以上5个中断源, 优先级按介绍由高到低(这个优先级只能在同产生时比较高低, 不能打断其他中断请求)

中断类型 中断型号
 0 		0003H
 1		000BH
 2		0013H
 3		001BH
 4		0023H

中断服务程序写法:
```
void 函数名(void) interrupt 
```

10. 程序设计要点
	1. 典型结构:主程序死循环加中断方式
	2. 初始化: 
		- 触发方式:IT0=1;边沿触发
		- 中断优先级:PX0=0;低优先级
		- 本中断开关闭合:EX0=1
		- 总中断闭合: EA=1
		> 注意总开关应该在最后关闭, 因为前面还在初始化, 不能说初始化时就开始执行中断
	3. 中断函数:
		```
		void 函数名(void) interrupt 中断号 using 工作组(可选,默认0号)
		{
			中断服务程序
		}
		```
	4. 中断属性表:
	中断号|中断类型|中断入口地址|引脚号
	-|-|-|-
	0|外部中断0|0x0003|P3.2
	1|定时中断0|0x000B|P3.4
	2|外部中断1|0x0013|P3.3
	3|定时中断1|0x001B|P3.5
	4|串口中断|0x0023|P3.0,P3.1
