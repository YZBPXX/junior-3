### 事物

#### 14.1事物的概念
1. 原子性:事物中的操作要就都做, 要就都不做
2. 一致性:数据库从一个一致性状态到另一个一致性状态
3. 隔离性:事物内部的操作及使用的数据对另一个事物是隔离的
4. 持久性:事物一旦提交, 对数据的改变是永久的

隔离级别:
1. 未提交读(脏读,不可重复读):T事物修改某一数据, 并写入磁盘, 此时S事物读取磁盘内容, 然而T事物出现某些情况撤销刚刚的操作. 就导致了S事物读取的数据是错误的数据
	- 问题: S可能是基于某个错误的数据产生的结果(脏读)
2. 读取提交内容(不可重复读): T事物只能访问S事物提交的数据
	- 问题: T事物两次读取内容不一致(不可重复读)
3. 可重复读(幻读): T事物读取某行数据, 此时S事物修改了该行数据, 但下次T读取的数据还是第一次读取到的, 并不会跟新为S修改后的数据
	- 问题: 读取的内容虽然一致, 但数据已经发生变化(幻读)
4. 可串行(排队)

封锁:
- 排他锁(X锁):若事物T对对象A加了X锁, 那么只允许T读取修改A. 其他事物不能对A加任何锁
- 共享锁(S锁):若事物T对对象A加了S锁, 那么只允许T读取A不能修改A. 其他事物只能对A加S锁. 不能对A加X锁
	- 问题(死锁): 使用共享锁修改数据时分两步,先获得共享锁, 读取数据, 然后升级为排它锁. 如果一条数据同时存在共享锁那么谁到不能升级到排它锁, 也就陷入了死循环(死锁)
- 跟新锁(U锁):锁定可能要修改的数据. 解决了上面死锁的问题
- 意向锁:对多粒度数中加意向锁, 说明该结点下层结点正在被加锁; 对任意结点加锁时, 上层结点必须已经加了意向锁

封锁协议:
- 一级封锁协议:事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。一级封锁协议可以防止丢失修改，并保证事务T是可恢复的。
- 二级封锁协议:在一级封锁协议基础上增加事务T在读数据R之前必须先对其加S锁，读完后即可释放S锁。二级封锁协议出防止了丢失修改，还可以进一步防止读“脏”数据。 
-  三级封锁协议:在二级封锁协议的基础上增加事务T在读数据R之前必须先对其加S锁，直到事务结束才释放。三级封锁协议出防止了丢失修改和读“脏”数据外，还可以进一步防止了不可重复读。

几种sql语句:
- Start transaction 开始事物
- commit 提交
- Rollback 回滚
